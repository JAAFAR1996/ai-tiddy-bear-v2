"""from datetime import datetimeimport asyncioimport loggingimport osfrom contextlib import asynccontextmanagerfrom fastapi import FastAPIfrom fastapi.middleware.cors import CORSMiddlewarefrom sqlalchemy.ext.asyncio import AsyncSession, create_async_enginefrom sqlalchemy.orm import sessionmakerimport redis.asyncio as redisfrom .endpoints import EmergencyEndpointsfrom .services import EmergencyResponseService, NotificationService, SystemMonitorService"""Emergency Response Main Module - Simplified main application"""logging.basicConfig(    level=logging.INFO,    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="api")# Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© - Ù…Ø­Ø³Ù‘Ù†Ø© Ù„Ù„Ø¥Ù†ØªØ§Ø¬REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379")# Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¢Ù…Ù†Ø© - PostgreSQL ÙÙ‚Ø· Ù„Ù„Ø¥Ù†ØªØ§Ø¬DATABASE_URL = os.getenv("DATABASE_URL")if not DATABASE_URL:    logger.critical("DATABASE_URL environment variable is required for emergency response")    raise RuntimeError("CRITICAL: DATABASE_URL must be set for emergency response system")# Ù…Ù†Ø¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… SQLite ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø±Ø¦ Ø§Ù„Ø­Ø±Ø¬if DATABASE_URL.startswith("sqlite"):    logger.critical("SQLite detected in emergency response system - SECURITY VIOLATION")    raise RuntimeError(        "CRITICAL: SQLite is not allowed for emergency response systems. "        "Use PostgreSQL for data integrity and COPPA compliance."    )# Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø©redis_client = Nonedb_session = Noneemergency_service = Nonemonitor_service = Nonenotification_service = Noneendpoints = None@asynccontextmanagerasync def lifespan(app: FastAPI):    """Ø¥Ø¯Ø§Ø±Ø© Ø¯ÙˆØ±Ø© Ø­ÙŠØ§Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""    global redis_client, db_session, emergency_service, monitor_service, notification_service, endpoints    logger.info("ğŸš¨ Starting Emergency Response System...")    try:        # Ø¥Ø¹Ø¯Ø§Ø¯ Redis        redis_client = redis.from_url(REDIS_URL)        await redis_client.ping()        logger.info("âœ… Redis connected")        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª        engine = create_async_engine(DATABASE_URL)        async_session = sessionmaker(engine, class_=AsyncSession)        db_session = async_session()        logger.info("âœ… Database connected")        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø§Øª        emergency_service = EmergencyResponseService(redis_client, db_session)        monitor_service = SystemMonitorService(redis_client)        notification_service = NotificationService(redis_client)        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©        endpoints = EmergencyEndpoints(emergency_service, monitor_service, notification_service)        logger.info("ğŸš¨ Emergency Response System started successfully")    except Exception as e:        logger.error(f"Failed to start Emergency Response System: {e}")        raise    yield    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯    logger.info("ğŸš¨ Shutting down Emergency Response System...")    if redis_client:        await redis_client.close()    if db_session:        await db_session.close()    logger.info("ğŸš¨ Emergency Response System shutdown complete")def create_app() -> FastAPI:    """Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ FastAPI"""    app = FastAPI(        title="ğŸš¨ AI Teddy Bear - Emergency Response",        description="Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ø±Ø¦Ø© Ù„Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø£Ù…Ù†ÙŠØ©",        version="1.0.0",        lifespan=lifespan    )    # Ø¥Ø¹Ø¯Ø§Ø¯ CORS Ø¢Ù…Ù†    allowed_origins = [        "http://localhost:3000",        "http://localhost:3001",        "https://yourdomain.com"  # Ø¥Ø¶Ø§ÙØ© Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø¥Ù†ØªØ§Ø¬    ]    app.add_middleware(        CORSMiddleware,        allow_origins=allowed_origins,        allow_credentials=True,        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],        allow_headers=["Authorization", "Content-Type", "X-Requested-With"],    )    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª    @app.post("/webhook/alerts")    async def webhook_alerts(request, payload, background_tasks):        return await endpoints.webhook_alerts(request, payload, background_tasks)    @app.get("/health")    async def health_check():        return await endpoints.health_check()    @app.get("/alerts")    async def get_alerts(credentials):        return await endpoints.get_alerts(credentials)    @app.post("/notifications")    async def send_notification(request, credentials):        return await endpoints.send_notification(request, credentials)    @app.get("/system/status")    async def system_status(credentials):        return await endpoints.system_status(credentials)    return app# Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„if __name__ == "__main__":    import uvicorn    API_PORT = int(os.getenv("API_PORT", 8080))    API_HOST = os.getenv("API_HOST", "0.0.0.0")    app = create_app()    uvicorn.run(app, host=API_HOST, port=API_PORT, reload=False)