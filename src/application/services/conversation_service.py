"""
Manages conversation history and interactions for children.

This service provides functionalities to start new conversations, retrieve
conversation history, and update conversation details such as analysis and
summaries. It interacts with the `ConversationRepository` to persist and
retrieve conversation data.
"""

import logging
from typing import List
from uuid import UUID

from src.domain.entities.conversation import Conversation
from src.domain.repositories.conversation_repository import ConversationRepository
from src.infrastructure.logging_config import get_logger

logger = get_logger(__name__, component="conversation_service")


class ConversationService:
    """Service for managing conversation history and interactions."""

    def __init__(
        self, conversation_repo: ConversationRepository, logger: logging.Logger = logger
    ) -> None:
        """Initializes the conversation service.

        Args:
            conversation_repo: The repository for conversation data.
            logger: Logger instance for logging service operations.
        """
        self.conversation_repo = conversation_repo
        self.logger = logger

    async def start_new_conversation(
        self, child_id: UUID, initial_text: str
    ) -> Conversation:
        """
        Starts a new conversation for a child.

        Args:
            child_id: The ID of the child.
            initial_text: The initial text of the conversation.

        Returns:
            The newly created conversation object.
        """
        conversation = Conversation.create_new(child_id)
        # Initial text can be part of summary
        conversation.update_summary(initial_text)
        await self.conversation_repo.save(conversation)
        return conversation

    async def get_conversation_history(
            self, child_id: UUID) -> List[Conversation]:
        """
        Retrieves the conversation history for a child.

        Args:
            child_id: The ID of the child.

        Returns:
            A list of conversation objects for the child.
        """
        return await self.conversation_repo.find_by_child_id(child_id)

    async def _get_conversation_by_id(
            self, conversation_id: UUID) -> Conversation:
        """
        Retrieves a conversation by its ID with error handling.

        Args:
            conversation_id: The ID of the conversation.

        Returns:
            The conversation entity.

        Raises:
            ValueError: If the conversation with the given ID is not found.
        """
        conversation = await self.conversation_repo.get_by_id(conversation_id)
        if not conversation:
            raise ValueError(
                f"Conversation with ID {conversation_id} not found.")
        return conversation

    async def update_conversation_analysis(
        self, conversation_id: UUID, emotion_analysis: str, sentiment_score: float
    ) -> Conversation:
        """
        Updates the emotional analysis and sentiment score of a conversation.

        Args:
            conversation_id: The ID of the conversation.
            emotion_analysis: The emotional analysis of the conversation.
            sentiment_score: The sentiment score of the conversation.

        Returns:
            The updated conversation object.
        """
        conversation = await self._get_conversation_by_id(conversation_id)
        conversation.update_analysis(emotion_analysis, sentiment_score)
        await self.conversation_repo.save(conversation)
        return conversation

    async def update_conversation_summary(
        self, conversation_id: UUID, summary: str
    ) -> Conversation:
        """
        Updates the summary of a conversation.

        Args:
            conversation_id: The ID of the conversation.
            summary: The new summary for the conversation.

        Returns:
            The updated conversation object.
        """
        conversation = await self._get_conversation_by_id(conversation_id)
        conversation.update_summary(summary)
        await self.conversation_repo.save(conversation)
        return conversation

    async def add_interaction(
        self, child_id: UUID, user_input: str, ai_response: str
    ) -> Conversation:
        """
        Adds a new interaction (user input and AI response) to a conversation.

        If no active conversation exists for the child, a new one is started.

        Args:
            child_id: The ID of the child.
            user_input: The input provided by the user.
            ai_response: The response generated by the AI.

        Returns:
            The updated or new conversation object.
        """
        # In a real scenario, you might have a way to get the active conversation
        # For simplicity, let's assume we always start a new one or get the
        # latest.
        conversations = await self.conversation_repo.find_by_child_id(child_id)
        if not conversations:
            self.logger.info(
                f"No active conversation found for child {child_id}. Starting a new one."
            )
            conversation = await self.start_new_conversation(child_id, user_input)
        else:
            # Sort conversations to reliably get the latest one
            conversation = sorted(
                conversations, key=lambda c: c.created_at, reverse=True
            )[0]
            self.logger.info(
                f"Using latest conversation {conversation.id} for child {child_id}."
            )

        conversation.add_interaction(user_input, ai_response)
        await self.conversation_repo.save(conversation)
        return conversation
