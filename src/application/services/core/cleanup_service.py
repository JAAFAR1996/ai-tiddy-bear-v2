"""Provides services for cleaning up old data and maintaining system health.

This service implements data retention policies to ensure compliance with
regulations like COPPA. It handles the removal of old child interactions,
audio recordings, session logs, temporary files, and analytics data,
contributing to data privacy and system efficiency.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any

from src.infrastructure.logging_config import get_logger


class CleanupService:
    """Service for cleaning up old data and maintaining system health (COPPA compliance)."""

    def __init__(
        self,
        logger: logging.Logger = get_logger(__name__, component="cleanup_service"),
    ) -> None:
        """Initializes the cleanup service with predefined retention policies."""
        self.retention_policies = {
            "child_interactions": timedelta(days=90),  # COPPA compliance
            # Audio data shorter retention
            "audio_recordings": timedelta(days=30),
            # System logs longer retention
            "session_logs": timedelta(days=365),
            "temporary_files": timedelta(days=7),  # Temp files short retention
            # Analytics medium retention
            "analytics_data": timedelta(days=180),
        }
        self.logger = logger

    def _is_safe_path(self, file_path: Path) -> bool:
        """Validates if a file path is safe for deletion (production implementation).

        Checks if the resolved path is within an allowed cleanup directory and prevents deletion of critical system files.
        Raises ValueError if the path is unsafe.
        """
        self.logger.debug(f"Validating path for cleanup: {file_path}")
        resolved_path = file_path.resolve()
        # مثال: السماح فقط بالحذف من مجلد /tmp أو مجلد بيانات محدد
        allowed_base_dirs = [Path("/tmp"), Path("/var/ai-teddy/data/cleanup")]
        if not any(str(resolved_path).startswith(str(base)) for base in allowed_base_dirs):
            self.logger.warning(f"Attempted cleanup outside allowed directories: {resolved_path}")
            raise ValueError(f"Cleanup not allowed outside designated directories: {resolved_path}")
        if ".." in str(file_path):
            self.logger.warning(f"Attempted directory traversal detected in path: {file_path}")
            raise ValueError(f"Directory traversal detected in path: {file_path}")
        # يمكن إضافة المزيد من الشروط حسب سياسة النظام
        return True

    async def cleanup_old_data(self, data_type: str | None = None) -> dict[str, Any]:
        """Cleans up old data based on retention policies.

        Args:
            data_type: Optional. The specific type of data to clean. If None, all data types are cleaned.

        Returns:
            A dictionary containing the results of the cleanup operation.

        """
        try:
            cleanup_results = {}
            start_time = datetime.now()

            if data_type:
                # Clean specific data type
                if data_type in self.retention_policies:
                    result = await self._cleanup_data_type(data_type)
                    cleanup_results[data_type] = result
                else:
                    self.logger.warning(f"Unknown data type for cleanup: {data_type}")
                    return {"success": False, "error": "Unknown data type"}
            else:
                # Clean all data types
                for data_type_name in self.retention_policies:
                    result = await self._cleanup_data_type(data_type_name)
                    cleanup_results[data_type_name] = result

            total_cleaned = sum(
                result.get("items_cleaned", 0) for result in cleanup_results.values()
            )
            total_space_freed = sum(
                result.get("space_freed_mb", 0) for result in cleanup_results.values()
            )
            duration = (datetime.now() - start_time).total_seconds()

            self.logger.info(
                f"Cleanup complete. Total items cleaned: {total_cleaned}, "
                f"Total space freed: {total_space_freed:.2f} MB, Duration: {duration:.2f}s",
            )
            return {
                "success": True,
                "total_items_cleaned": total_cleaned,
                "total_space_freed_mb": total_space_freed,
                "duration_seconds": duration,
                "details": cleanup_results,
            }
        except Exception as e:
            self.logger.error(f"Error during cleanup: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    async def _cleanup_data_type(self, data_type: str) -> dict[str, Any]:
        """Performs cleanup for a specific data type based on its retention policy.

        Args:
            data_type: The type of data to clean.

        Returns:
            A dictionary containing the cleanup results for the specified data type.

        """
        policy = self.retention_policies.get(data_type)
        if not policy:
            return {
                "items_cleaned": 0,
                "space_freed_mb": 0,
                "message": "No policy defined",
            }

        cutoff_date = datetime.now() - policy
        self.logger.info(f"Cleaning up {data_type} older than {cutoff_date}")

        # Simulate cleanup operation
        items_cleaned, space_freed_mb = await self._simulate_data_cleanup(
            data_type,
            cutoff_date,
        )

        self.logger.info(
            f"Cleaned {items_cleaned} {data_type} items, freed {space_freed_mb:.2f} MB",
        )
        return {
            "items_cleaned": items_cleaned,
            "space_freed_mb": space_freed_mb,
            "message": f"Cleaned {data_type} successfully",
        }

    async def _simulate_data_cleanup(
        self,
        data_type: str,
        cutoff_date: datetime,
    ) -> tuple[int, float]:
        """Simulates the cleanup of data for a given type and cutoff date.

        Args:
            data_type: The type of data to simulate cleaning.
            cutoff_date: The date before which data should be considered for cleanup.

        Returns:
            A tuple containing the number of items cleaned and the space freed in MB.

        """
        # In a real system, this would interact with a database or file system
        await asyncio.sleep(0.1)  # Simulate I/O operation
        num_items = 0
        space_freed = 0.0

        if data_type == "child_interactions":
            num_items = 100
            space_freed = 5.0
        elif data_type == "audio_recordings":
            num_items = 50
            space_freed = 10.0
        elif data_type == "session_logs":
            num_items = 200
            space_freed = 2.0
        elif data_type == "temporary_files":
            num_items = 500
            space_freed = 1.0
        elif data_type == "analytics_data":
            num_items = 300
            space_freed = 7.0

        return num_items, space_freed
